# -*- coding: utf-8 -*-
"""detection_persuasion_techniques_memes_electra_version.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oww2SbJ6bznfnVWZuYPk61M7Byym8aen

<a href="https://colab.research.google.com/github/GianRomani/Detection-of-Persuasion-Techniques-in-Texts-and-Images/blob/main/detection_persuasion_techniques_memes.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>

# Import
"""

from google.colab import drive
drive.mount('/content/drive')

! pip install  "datasets" "transformers" "pytorch-lightning"

pip install torch

import torch
from torch.utils.data import (
    Dataset, TensorDataset,
    DataLoader, RandomSampler,
    SequentialSampler)
import torch.nn as nn
import torchmetrics
import torchmetrics.functional as func

from pytorch_lightning import (
    LightningDataModule, LightningModule,
    Trainer, seed_everything)
from pytorch_lightning.loggers import TensorBoardLogger
from pytorch_lightning.callbacks import Callback
from transformers import (
    AdamW,
    AutoConfig,
    AutoModel,
    AutoTokenizer,
)

import csv
import gc
import re
import numpy as np
import pandas as pd

from sklearn.preprocessing import MultiLabelBinarizer
from sklearn.model_selection import train_test_split

import sklearn.metrics
from sklearn.metrics import confusion_matrix, f1_score
from sklearn.metrics import classification_report
from sklearn.utils.multiclass import unique_labels
import matplotlib.pyplot as plt


def plot_confusion_matrix(cm, num_classes=14, title='confusion matrix',
                          classes=['negative', 'positive'], cmap=plt.cm.YlGn):

    title = title

    fig, ax = plt.subplots()
    im = ax.imshow(cm, interpolation='nearest', cmap=cmap)
    ax.figure.colorbar(im, ax=ax)

    ax.set(xticks=np.arange(cm.shape[1]),
           yticks=np.arange(cm.shape[0]),
           title=title,
           yticklabels=classes,
           ylabel='True label',
           xlabel='Predicted label')

    ax.set_ylim(num_classes-0.5, -0.5)

    fmt = 'd'
    thresh = cm.max() / 2.
    for i in range(cm.shape[0]):
        for j in range(cm.shape[1]):
            ax.text(j, i, format(cm[i, j], fmt),
                    ha="center", va="center",
                    color="white" if cm[i, j] > thresh else "black")
    fig.tight_layout()
    return ax

def plot_confusion_multi(all_cm, classes):
  assert len(all_cm)==len(classes)
  label =0
  for cm in all_cm:
    class_name=classes[label]
    title="confusion matrix for "+str(class_name)
    plot_confusion_matrix(cm,2,title=title)
    label=label+1

AVAIL_GPUS = 0
if torch.cuda.is_available():
    device = torch.device("cuda")
    AVAIL_GPUS = torch.cuda.device_count()
    print(f'There are {AVAIL_GPUS} GPU(s) available.')
    print('Device name:', torch.cuda.get_device_name(0))

else:
    print('No GPU available, using the CPU instead.')
    device = torch.device("cpu")

seed_everything(42)

"""# Main Folders

In order to run the whole code it is necessary to add a shortcut from the shared folder "DeepProject" to "MyDrive" folder, or change the **folder_name** variable, setting it to the right path.
"""

folder_name = "/content/drive/MyDrive/DeepProject/"
logs_dir = folder_name + "Logs/"

"""# Pre-trained Transformer Name

This section is used to choose which pre-trained model to load from HuggingFace library.
"""

#pretrained_transformer_name = "distilbert-base-cased"
pretrained_transformer_name = "google/electra-base-discriminator"
#pretrained_transformer_name = "microsoft/deberta-base"
#pretrained_transformer_name = "albert-base-v2"
#pretrained_transformer_name = "distilbert/distilroberta-base"

checkpoint_name= pretrained_transformer_name.replace("/","_")

"""# PTC: Propaganda Techniques corpus
For Subtask1 and Subtask2 **transfer learning** is applied: the language models are pre-trained on PTC articles corpus from [PTC TASKS ON
"DETECTION OF PROPAGANDA TECHNIQUES IN NEWS ARTICLES" challenge](https://propaganda.math.unipd.it/ptc/) (task TC). It is a dataset that labels about 450 news articles into 14 propaganda techniques.

## Data pre-processing

We generated a multi-class dataset associating to each sentence a label, starting from PTC labeling of the spans in each news article, obtaining 6128 train samples and 1063 test samples.
"""

train_PTC_labels_file_name = folder_name + "Dataset/PTC/train-task-flc-tc.labels"
train_articles_folder = folder_name + "Dataset/PTC/train-articles/"
train_PTC_dataset_file_name = folder_name + "Dataset/PTC_dataset.csv"

val_PTC_labels_file_name = folder_name + "Dataset/PTC/dev-task-flc-tc.labels"
val_articles_folder = folder_name + "Dataset/PTC/dev-articles/"
val_PTC_dataset_file_name = folder_name + "Dataset/PTC_validation_dataset.csv"

PTC_checkpoints= folder_name + "Model/PTC/"

"""Function used only once to create the csv dataset from the PTC articles corpus."""

def create_dataset(input_name, output_name, articles_folder):
    f_output = open(output_name, 'w')

    with open(input_name, 'r') as f:
        writer = csv.writer(f_output)
        writer.writerow(['text', 'label'])
        article_file_name = ""
        af = None
        for line in f:
            fields = line.split('\t')
            id_file = fields[0]
            label = fields[1]
            begin_offset = int(fields[2])
            end_offset = int(fields[3])
            file_name = articles_folder + "article" + id_file + ".txt"

            if(file_name != article_file_name):
                if(af != None):
                    af.close()
                article_file_name = articles_folder + "article" + id_file + ".txt"
                af = open(article_file_name, 'rb')

            af.seek(begin_offset)
            assert end_offset - begin_offset > 0
            text = af.read(
                end_offset - begin_offset).decode('utf-8', 'ignore').strip()
            text = re.sub('[^A-Za-z0-9!?()%-= \']+', '', text)

            writer.writerow([text, label])

    af.close()
    f.close()
    f_output.close()

# create_dataset(train_PTC_labels_file_name,train_PTC_dataset_file_name, train_articles_folder)
# create_dataset(val_PTC_labels_file_name,val_PTC_dataset_file_name, val_articles_folder)

"""## PTC - Training

### Dataset
"""

class PTCDataset(Dataset):
    def __init__(self, input_id, attention, labels):
        self.attention = attention
        self.input_id = input_id
        self.labels = labels

    def __len__(self):
        return len(self.labels)

    def __getitem__(self, idx):
        attention = self.attention[idx]
        label = self.labels[idx]
        input_id = self.input_id[idx]
        sample = {"attention_mask": attention,
                  "input_ids": input_id, "labels": label}
        return sample

train_data = pd.read_csv(train_PTC_dataset_file_name)
val_data = pd.read_csv(val_PTC_dataset_file_name)

"""Overview of the dataset characteristics and of the distribution of the classes."""

train_data

train_data.describe()

frequences = train_data.groupby(['label']).size()
frequences

"""As we can see in the plot below, the distribution of the samples among the classes is not balanced. This means that we could expect good results for certain classes and bad for others or, in the worst scenario, our models could be heavily biased towards the classes which have more samples. To mitigate this problem we focused on trying different kinds of loss functions."""

frequences.plot(kind='bar')

"""### Define LightningDataModule

In the DataModule the sentences are encoded by a tokenizer that adds special tokens and padding, truncates to the maximum length (computed by the maxLen function) and returns the attention mask and the token ids.

We can pass the model's name as parameter to the DataModule, in this way the tokenizer's output is going to be appropriate for such model.
"""

class PTCDataModule(LightningDataModule):
    def __init__(
        self,
        train_data,
        val_data,
        model_name: str = "google/electra-base-discriminator",
        batch_size: int = 32,
        **kwargs,
    ):
        super().__init__()
        self.train_data = train_data
        self.val_data = val_data
        self.batch_size = batch_size
        self.num_labels = 14
        self.tokenizer = AutoTokenizer.from_pretrained(
            model_name, do_lower_case=False)
        self.le = preprocessing.LabelEncoder()

    def setup(self, stage: str = None):
        self.X_train = self.train_data.text.values
        self.le.fit(self.train_data.label.values)
        y_train = self.le.transform(self.train_data.label.values)

        self.X_val = self.val_data.text.values
        y_val = self.le.transform(self.val_data.label.values)

        self.max_length = self.maxLen()

        self.X_train_enc, self.X_train_attention = self.preprocessing(
            self.X_train)
        self.X_val_enc, self.X_val_attention = self.preprocessing(
            self.X_val)

        self.y_train = torch.tensor(y_train)
        self.y_val = torch.tensor(y_val)

    def prepare_data(self):
        return

    def train_dataloader(self):
        data = PTCDataset(self.X_train_enc,
                          self.X_train_attention, self.y_train)
        train_dataloader = DataLoader(data, batch_size=self.batch_size)
        return train_dataloader

    def val_dataloader(self):
        data = PTCDataset(self.X_val_enc, self.X_val_attention, self.y_val)
        val_dataloader = DataLoader(data, batch_size=self.batch_size)
        return val_dataloader

    def preprocessing(self, data):
        input_ids = []
        attention_masks = []

        for sent in data:
            encoded_sent = self.tokenizer.encode_plus(
                text=sent,
                add_special_tokens=True,
                max_length=self.max_length,
                pad_to_max_length=True,
                truncation=True,
                return_attention_mask=True
            )

            input_ids.append(encoded_sent.get('input_ids'))
            attention_masks.append(encoded_sent.get('attention_mask'))

        input_ids = torch.tensor(input_ids)
        attention_masks = torch.tensor(attention_masks)

        return input_ids, attention_masks

    def maxLen(self):
        X_all = np.concatenate([self.X_train, self.X_val])

        encoded_X = [
            self.tokenizer.encode(
                sent,
                add_special_tokens=True
            ) for sent in X_all
        ]

        max_len = max([len(sent) for sent in encoded_X])
        return max_len

seed_everything(42)
dm = PTCDataModule(train_data, val_data,
                   model_name=pretrained_transformer_name, batch_size=16)
dm.setup()

"""### Loss Functions"""

class FocalLoss(nn.Module):
    def __init__(self, gamma=2):
        super(FocalLoss, self).__init__()
        self.gamma = gamma
        self.CE = torch.nn.CrossEntropyLoss(reduction='none')

    def forward(self, inputs, targets):
        CE_loss = self.CE(inputs,targets)
        pt = torch.exp(-CE_loss)
        F_loss = (1-pt)**self.gamma * CE_loss

        return torch.mean(F_loss)

"""### Model

Class that implements the callback that prints the metrics that are used to evaluate a model.
"""

class PTCEvaluateCallback(Callback):
    def on_fit_end(self, trainer, model):
        print("Fit end: Evaluation....")

        all_predictions = model.predictions.detach().cpu().numpy().astype(int) # Changed np.int to int
        all_labels = model.labels.detach().cpu().numpy().astype(int) # Changed np.int to int

        classes = model.le.classes_

        print("F1-micro: {}".format(f1_score(all_labels,
              all_predictions, average='micro', zero_division=1)))
        print("F1-macro: {}".format(f1_score(all_labels,
              all_predictions, average='macro', zero_division=1)))

        print(classification_report(all_labels, all_predictions, labels=[
              i for i in range(model.num_classes)], target_names=classes))

        conf_mat = confusion_matrix(all_labels, all_predictions)
        plot_confusion_matrix(conf_mat, classes=classes)

        return

class CLSExtractor(nn.Module):
    def __init__(self, name):
        super(CLSExtractor, self).__init__()
        self.isCLSLast = (True if name == 'xlnet-base-cased' else False)

    def forward(self, x):
        if(self.isCLSLast):
            return x[0][:, -1, :]
        else:
            return x[0][:, 0, :]

class PTCTransformer(LightningModule):
    def __init__(
        self,
        le,
        y_train=None,
        num_classes: int = 14,
        model_name_or_path: str = "google/electra-base-discriminator",
        learning_rate: float = 2e-5,
        adam_epsilon: float = 1e-8,
        batch_size: int = 32,
        **kwargs,
    ):
        super().__init__()

        self.num_classes = num_classes

        self.learning_rate = learning_rate
        self.adam_epsilon = adam_epsilon

        self.save_hyperparameters()

        self.le = le

        #self.loss = nn.CrossEntropyLoss()
        self.loss = FocalLoss()
        #self.loss = WeightedCELoss(y_train)
        self.acc = torchmetrics.Accuracy(task='multiclass', num_classes=num_classes)

        self.labels = torch.Tensor(device=self.device)
        self.predictions = torch.Tensor(device=self.device)

        self.outputs = []  # Initialize an empty list to store outputs

        D_in, H, D_out = 768, 96, num_classes
        self.transformer = AutoModel.from_pretrained(model_name_or_path)

        self.extractor = CLSExtractor(model_name_or_path)

        self.classifier = nn.Sequential(
            nn.Linear(D_in, H),
            nn.LeakyReLU(0.01),
            nn.Dropout(0.1),
            nn.Linear(H, D_out)
        )

    def forward(self, **inputs):
        plm_output = self.transformer(input_ids=inputs["input_ids"],
                                      attention_mask=inputs["attention_mask"])

        last_hidden_state_cls = self.extractor(plm_output)

        logits = self.classifier(last_hidden_state_cls)

        return logits

    def training_step(self, batch, batch_idx):
        labels = batch["labels"]
        logits = self(**batch)
        loss = self.loss(logits, labels)
        self.log('train_loss', loss, prog_bar=True,
                 on_epoch=True, on_step=True,  logger=True)
        predictions = torch.argmax(torch.softmax(logits, dim=1), axis=1)
        acc = self.acc(predictions, labels)
        self.log('train_acc', acc, prog_bar=True,
                 on_epoch=True, on_step=True,  logger=True)
        return {"loss": loss, "accuracy": acc}

    def validation_step(self, batch, batch_idx, dataloader_idx=0):
        logits = self(**batch)
        labels = batch["labels"]
        val_loss = self.loss(logits, labels)
        self.log('val_loss', val_loss, prog_bar=True,
                 on_epoch=True, on_step=True, logger=True)
        predictions = torch.argmax(logits, axis=1)
        acc = self.acc(predictions, labels)
        self.log('val_acc', acc, prog_bar=True,
                 on_epoch=True, on_step=True,  logger=True)

        self.outputs.append({"loss": val_loss, "accuracy": acc, # Append outputs to self.outputs
                "predictions": predictions, "labels": labels})

        return {"loss": val_loss, "accuracy": acc,
                "predictions": predictions, "labels": labels}

    def validation_step_end(self, outputs):
        return outputs

    def on_validation_epoch_end(self):
        if(self.current_epoch == self.trainer.max_epochs - 1):
            labels = [x["labels"] for x in self.outputs] # Access self.outputs
            self.labels = torch.cat(labels, dim=0)

            predictions = [x["predictions"] for x in self.outputs]
            self.predictions = torch.cat(predictions, dim=0)

    def configure_optimizers(self):
        """
        Configure the optimizers and learning rate schedulers.
        """
        optimizer = AdamW(self.parameters(), lr=self.learning_rate, eps=self.adam_epsilon)
        # You can add a learning rate scheduler here if needed
        # scheduler = ...
        # return [optimizer], [scheduler]  # If using a scheduler
        return optimizer

"""### Training"""

model = PTCTransformer(dm.le, dm.y_train, model_name_or_path=pretrained_transformer_name)

log_dir = logs_dir+"PTC/"

logger = TensorBoardLogger(log_dir, name="PTC_net_"+checkpoint_name, version="TEST", log_graph=True)

# Install pytorch-lightning if it's not already installed:
#!pip install pytorch-lightning

import pytorch_lightning as pl

# ... other imports ...

trainer = pl.Trainer(max_epochs=3, accelerator="gpu", devices=AVAIL_GPUS, logger=logger, callbacks=[
                  PTCEvaluateCallback()])

# trainer = Trainer(max_epochs=3, gpus=AVAIL_GPUS, logger=logger, callbacks=[
#                   PTCEvaluateCallback()])

trainer.fit(model, dm)

"""This command is used to save checkpoints needed for subtask 1.

It is commented to not overwrite the checkpoints of the best performing model already saved.
"""

trainer.save_checkpoint(PTC_checkpoints+"PTC_"+checkpoint_name+"_FL.ckpt")

# Save the model
model_save_path = PTC_checkpoints + "PTC_" + checkpoint_name + "_FL.ckpt"

print(f"Model saved to: {model_save_path}") # Print the save path

# checkpoint_path ="/content/drive/MyDrive/DeepProject/Model/PTC/PTC_bert-base-cased_FL.ckpt"
# PTC_checkpoints = torch.load(checkpoint_path)

"""# Subtask 1
Given the textual content of a meme, identify which of the 20 techniques are used in it (multilabel classification problem)

The main paper from which we got inspired is: [MinD at SemEval-2021 Task 6](https://aclanthology.org/2021.semeval-1.150.pdf), which ranked first in the challenge.

The approach used from the MinD team consists in fine tuning different pre-trained transformers models and then ensemble them to obtain the final predictions by averaging the probabilities from the models.

The models we fine-tuned are the ones obtained from the previous section (PTC).

The official evaluation measure for this subtask is micro-F1.
"""

gc.collect()

Task1_checkpoints= folder_name + "Model/SubTask1/"

"""## Dataset

The train, dev and test datasets contain 688, 63 and 200 memes respectively.

The distribution of samples among the classes is highly unbalanced (similarly to PTC's dataset).

![Subtask1.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAuQAAAH8CAYAAACZyboOAAAK1mlDQ1BJQ0MgUHJvZmlsZQAASImVlwdYU1kWgO97L52EkoTeQm+CdAJICaEFUJAOohKSQEIJMSGo2BAZHMGxoCICNnRURMHREZCxIBYsDIq9D8ggoKyDBRso+4AlzMx+u/vt+b7zzp/zzj333Pvdm+88AChhXIkkE1YFIEucI40M8mPEJyQy8C8AAqhABX2qc3kyCSsiIgygMmX/Kh/uAWjc3rYdz/Xv7/+rUPkCGQ8AKAnlFL6Ml4VyC6qveRJpDgDIMdRvsjhHMs53UKZL0QJR7h/ntEkeHeeUCcaoTsRER7JRNgWAQOZypWkAkO1RPyOXl4bmIUegbC/mi8Qo56PszRNy+Sij84IZWVnZ4zyIsiUaLwGAQkeZmfKnnGl/yZ+iyM/lpil4cl0TQvAXySSZ3KX/59b8b8nKlE/NYY4qWSgNjkStBrp/DzKyQxUsTpkTPsUi/kT8BAvlwTFTzJOxE6eYz/UPVYzNnBM2xamiQI4iTw4neooFsoCoKZZmRyrmSpWyWVPMlU7PK8+IUfiFAo4if54wOm6Kc0Wxc6ZYlhEVOh3DVvil8khF/QJxkN/0vIGKtWfJ/rReEUcxNkcYHaxYO3e6foGYNZ1TFq+ojS/wD5iOiVHES3L8FHNJMiMU8YLMIIVflhulGJuDHs7psRGKPUznhkRMMXAAbsAYMEA0CETVFoQBNvAHIEewJGd8MexsyVKpKE2Yw2ChN07A4Ih5djMYjvaOjgCM39/JIzF0Y+JeQtpq0z55PnrcGwCAC6Z9C9HaausB0K6f9hmrAaBeCUDDCE8uzZ30YcYfWEBC/xfoQBsYABNgidbmCFyBJ/AFASAEhKPVJoAFgAeEIAtIwWKwHKwGRaAEbALbQAXYDfaBQ+AoOA4awWlwHlwG18FNcBc8Bl2gF7wCQ+ADGIEgCA9RIBqkDRlCZpAN5AgxIW8oAAqDIqEEKBlKg8SQHFoOrYFKoFKoAtoL1UA/Qaeg89BVqBN6CHVDA9Bb6AuMwGSYDuvD5vBMmAmz4FA4Gp4Pp8GL4Dy4EN4Al8PV8BG4AT4PX4fvwl3wK3gYAYgSooEYIbYIE2Ej4UgikopIkZVIMVKGVCN1SDPShtxGupBB5DMGh6FhGBhbjCcmGBOD4WEWYVZi1mMqMIcwDZiLmNuYbswQ5huWgtXD2mA9sBxsPDYNuxhbhC3DHsCexF7C3sX2Yj/gcDgNnAXODReMS8Cl45bh1uN24upxLbhOXA9uGI/Ha+Nt8F74cDwXn4Mvwu/AH8Gfw9/C9+I/EZQIhgRHQiAhkSAmFBDKCIcJZwm3CH2EEaIq0YzoQQwn8olLiRuJ+4nNxBvEXuIISY1kQfIiRZPSSatJ5aQ60iXSE9I7JSUlYyV3pblKIqV8pXKlY0pXlLqVPpOpZGsym5xElpM3kA+SW8gPye8oFIo5xZeSSMmhbKDUUC5QnlE+KdOU7ZQ5ynzlVcqVyg3Kt5RfqxBVzFRYKgtU8lTKVE6o3FAZVCWqmquyVbmqK1UrVU+p3lcdVqOpOaiFq2WprVc7rHZVrZ+Kp5pTA6h8aiF1H/UCtYeG0ExobBqPtoa2n3aJ1kvH0S3oHHo6vYR+lN5BH1Knqjurx6ovUa9UP6PepYFomGtwNDI1Nmoc17in8UVTX5OlKdBcp1mneUvzo5aulq+WQKtYq17rrtYXbYZ2gHaG9mbtRu2nOhgda525Oot1dulc0hnUpet66vJ0i3WP6z7Sg/Ws9SL1lunt02vXG9Y30A/Sl+jv0L+gP2igYeBrkG6w1eCswYAhzdDbUGS41fCc4UuGOoPFyGSUMy4yhoz0jIKN5EZ7jTqMRowtjGOMC4zrjZ+akEyYJqkmW01aTYZMDU1nmy43rTV9ZEY0Y5oJzbabtZl9NLcwjzNfa95o3m+hZcGxyLOotXhiSbH0sVxkWW15xwpnxbTKsNppddMatnaxFlpXWt+wgW1cbUQ2O206Z2BnuM8Qz6iecd+WbMuyzbWtte2207ALsyuwa7R7PdN0ZuLMzTPbZn6zd7HPtN9v/9iB6hDiUODQ7PDW0dqR51jpeMeJ4hTotMqpyemNs42zwHmX8wMXmstsl7UurS5fXd1cpa51rgNupm7JblVu95l0ZgRzPfOKO9bdz32V+2n3zx6uHjkexz3+8LT1zPA87Nk/y2KWYNb+WT1exl5cr71eXd4M72TvPd5dPkY+XJ9qn+e+Jr583wO+fSwrVjrrCOu1n72f1O+k30e2B3sFu8Uf8Q/yL/bvCKAGxARUBDwLNA5MC6wNHApyCVoW1BKMDQ4N3hx8n6PP4XFqOEMhbiErQi6GkkOjQitCn4dZh0nDmmfDs0Nmb5n9ZI7ZHPGcxnAQzgnfEv40wiJiUcQvc3FzI+ZWzn0R6RC5PLItiha1MOpw1Idov+iN0Y9jLGPkMa2xKrFJsTWxH+P840rjuuJnxq+Iv56gkyBKaErEJ8YmHkgcnhcwb9u83iSXpKKke/Mt5i+Zf3WBzoLMBWcWqizkLjyRjE2OSz6cPMoN51Zzh1M4KVUpQzw2bzvvFd+Xv5U/IPASlAr6Ur1SS1P707zStqQNCH2EZcJBEVtUIXqTHpy+O/1jRnjGwYyxzLjM+ixCVnLWKTFVnCG+mG2QvSS7U2IjKZJ0LfJYtG3RkDRUekAGyebLmnLoaKPULreUfyfvzvXOrcz9tDh28YklakvES9qXWi9dt7QvLzDvx2WYZbxlrcuNlq9e3r2CtWLvSmhlysrWVSarClf15gflH1pNWp2x+tcC+4LSgvdr4tY0F+oX5hf2fBf0XW2RcpG06P5az7W7v8d8L/q+Y53Tuh3rvhXzi6+V2JeUlYyu562/9oPDD+U/jG1I3dCx0XXjrk24TeJN9zb7bD5UqlaaV9qzZfaWhq2MrcVb329buO1qmXPZ7u2k7fLtXeVh5U07THds2jFaIay4W+lXWV+lV7Wu6uNO/s5bu3x31e3W312y+8se0Z4He4P2NlSbV5ftw+3L3fdif+z+th+ZP9Yc0DlQcuDrQfHBrkORhy7WuNXUHNY7vLEWrpXXDhxJOnLzqP/Rpjrbur31GvUlx8Ax+bGXPyX/dO946PHWE8wTdT+b/Vx1knayuAFqWNow1Chs7GpKaOo8FXKqtdmz+eQvdr8cPG10uvKM+pmNZ0lnC8+Oncs7N9wiaRk8n3a+p3Vh6+ML8RfuXJx7seNS6KUrlwMvX2hjtZ274nXl9FWPq6euMa81Xne93tDu0n7yV5dfT3a4djTccLvRdNP9ZnPnrM6zt3xunb/tf/vyHc6d63fn3O28F3Pvwf2k+10P+A/6H2Y+fPMo99HI4/wn2CfFT1Wflj3Te1b9m9Vv9V2uXWe6/bvbn0c9f9zD63n1u+z30d7CF5QXZX2GfTX9jv2nBwIHbr6c97L3leTVyGDRP9T+UfXa8vXPf/j+0T4UP9T7Rvpm7O36d9rvDr53ft86HDH87EPWh5GPxZ+0Px36zPzc9iXuS9/I4lH8aPlXq6/N30K/PRnLGhuTcKXciVYAQRVOTQXg7UG0P04AgHYTANK8yf56QqDJb4IJAv+JJ3vwCXEFoBrtTeJ9AQhrAWA76jJBLR39HY5qtC+AnZwU+i+RpTo5TuZSrgUAbzQ29jYbACKqo0FjYyMRY2Nfqya/G872T/b148LDTo1vMd8D/i6TPf+f1vh3C8YrcAZ/t/8EHEMW1VyZvzQAAABWZVhJZk1NACoAAAAIAAGHaQAEAAAAAQAAABoAAAAAAAOShgAHAAAAEgAAAESgAgAEAAAAAQAAAuSgAwAEAAAAAQAAAfwAAAAAQVNDSUkAAABTY3JlZW5zaG905a//WQAAAdZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDYuMC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+NTA4PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjc0MDwvZXhpZjpQaXhlbFhEaW1lbnNpb24+CiAgICAgICAgIDxleGlmOlVzZXJDb21tZW50PlNjcmVlbnNob3Q8L2V4aWY6VXNlckNvbW1lbnQ+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgrYmYTXAABAAElEQVR4AeydB4AdVb3/f9tbeg8JJBAgIRA6SJUWAghPLA8UQaSIT5SOBcGH+pfyAAUU3xOeYnxKFewNpUhHSURKQg0EQkJ6SN++93++Z/bcnb25d/fu3Xu3ZD8n2TszZ075nc+ZO/d7fnNmpijhghEgAAEIQAACEIAABCAAgV4hUNwrtVIpBCAAAQhAAAIQgAAEIOAJIMg5ECAAAQhAAAIQgAAEINCLBBDkvQifqiEAAQhAAAIQgAAEIIAg5xiAAAQgAAEIQAACEIBALxJAkPcifKqGAAQgIAK6t7637q/vzbrpfQhAAAIQiAgUuZMxT1nhaIAABCCQI4FUQVtUVGT6GwihpaXFN7O4GN/OQOhv2ggBCBSOAGfRwrGlZAhAYCsnIDEu8S1BGv68GO+Cm0NlrFixwtavW98pLQngfPpQVN6yZcts48aNndYdTxBsCG2O72MdAhCAAAS6TgBB3nVm5IAABCDghbHE9/r16+1f//qXPfzww/bCCy/Ypk2bzJyDPIjWTKjC/traWjv33HPtN7/9jU8a4tPlkwBWnR2lSZcvNS7kl+0f/ehH7ZGHH+m07lCG8vpBh4t4+eWXbd68ed22J5TNEgIQgMBAJYAgH6g9T7shAIGcCQRR+uqrr9qpp55qZ511ls2ePduOOeYYv75u3bqkcE7n1U6Nq66utpKSEm+P9qXu1466ujp7+umnbdGiRb5spQlB9oR88fiM+2Me/OHDh1tRcdsUm1CWxdLEy5EYX7Nmjd18882266672q233mqNjY0+iTODAAEIQAACORBAkOcAjSwQgMDAJRDEuASyROn2229vf/7zn+2nP/2pPf/883byyScnPcYSr8GrHRe46aZ6BCEtYZ7M4zCH+KamJjv44IN9HaKvNCGEeuLlyk6FYG/Y58uOCfBQvtK2tLRNwUn18ody5s+fbzvttJOtWrXKvvzlL9vgwYOTHvM2Wa/SCBCAAAQgkC2B0mwTkg4CEIAABNoIaGqKpmx88YtftHHjxvkdWn784x9PJtLc7Ndff90LWAlXBQnbV155xWpqamzSpEk+TmK7oqLCGhoa3fSX59yywSZPnmzbbrutF97yuGtqyCc+8QkvhF977TUrKyuzHXbYweeX11x/Etdjx461HafsaCWlJUkxrsGD8qxevdpGjxptO0/d2dcnW/QXQklJsS//7YVv29RpU73YDkI8pFG777rrLn814Hvf+54tWLAg7GIJAQhAAAI5EmhzseRYANkgAAEIDEQCmmaiKRvyji9cuDCJoLm5OenVlkjeZ5997O23307ur6+vt8suu8x++9vf+jiJ6CFDhnhxf8klF9vXv/51+8///E877LDD7LHHHvNpXnzxRfvUpz5llZWV9te//tU++clP2t13320S8vLSS9j//Oc/tx//+Mc2bdo0+9nPf+ZtkOdcYv4b3/iGXXDBBfbQQw/Zsccda/fd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)
"""

dataset_folder=folder_name+"PTC_Dataset/"
train_st1 = "/content/drive/MyDrive/DeepProject/training_set_task1.txt"
dev_st1 = "/content/drive/MyDrive/DeepProject/dev_set_task1.txt"
test_st1 = "/content/drive/MyDrive/DeepProject/test_set_task1.txt"

train_data1=pd.read_json(train_st1)
dev_data1=pd.read_json(dev_st1)
test_data1=pd.read_json(test_st1)

train_data1

print("Number of samples in the train dataset: {}, validation dataset: {} and test dataset: {}".format(len(train_data1.text.values), len(dev_data1.text.values), len(test_data1.text.values)))

techniques = [['Appeal to authority', 'Appeal to fear/prejudice', 'Bandwagon',
               'Black-and-white Fallacy/Dictatorship',
               'Causal Oversimplification', 'Doubt', 'Exaggeration/Minimisation',
               'Flag-waving', 'Glittering generalities (Virtue)',
               'Loaded Language',
               "Misrepresentation of Someone's Position (Straw Man)",
               'Name calling/Labeling',
               'Obfuscation, Intentional vagueness, Confusion',
               'Presenting Irrelevant Data (Red Herring)', 'Reductio ad hitlerum',
               'Repetition', 'Slogans', 'Smears', 'Thought-terminating clich',
               'Whataboutism']]

class Task1Dataset(Dataset):
    def __init__(self, input_id, attention, labels):
        self.attention = attention
        self.input_id = input_id
        self.labels = labels

    def __len__(self):
        return len(self.labels)

    def __getitem__(self, idx):
        attention = self.attention[idx]
        label = self.labels[idx]
        input_id = self.input_id[idx]
        sample = {"attention_mask": attention,
                  "input_ids": input_id, "labels": label}
        return sample

"""##Loss Functions

To deal with this unbalanced dataset, we tried to use several loss functions that could handle such disparities.

A first approach consisted in a weighted version of Binary Cross Entropy which adds weights to positive samples in the loss function with the following formula (from [Volta at SemEval-2021 Task 6](https://arxiv.org/pdf/2106.00240.pdf)):

$l(x,y) = - \dfrac{1}{Nd}\sum_{n=1}^{N}\sum_{k=1}^{d}[p^k y_n^k \log(x_n^k) + (1 - y_n^k)\log(1-x_n^k)]$

where $p^k = \dfrac{1}{f^k}(|K| - f^k)$, $N$ is the batch size, $n$ is and index for the $n^{th}$ batch element, $d$ is the number of classes, $f$ stands for a vector of class absolute frequencies, $x$ is a vector from the last Sigmoid layer, y is a vector representing the labels and $|K|$ is the size of the train set.
"""

class WeightedBCELoss(nn.Module):
    def __init__(self, y_train):
        super(WeightedBCELoss, self).__init__()
        self.y_train = y_train
        self.pos_weight = self.weighted_factors()

    def forward(self, logits, labels):
        loss = torch.nn.BCEWithLogitsLoss(
            pos_weight=self.pos_weight, reduction='mean')
        return loss(logits, labels)

    def weighted_factors(self):
        f = torch.sum(self.y_train, dim=0)
        N = len(self.y_train)
        K = torch.full(size=f.size(), fill_value=N)
        pos_weight = torch.div(torch.sub(K, f), f).to(device=device)
        return pos_weight

"""As second approach we use [Focal loss](https://arxiv.org/pdf/1708.02002.pdf) which focuses on improving predictions on hard misclassified examples.

This is achieved by adding the two hyper-parameters to the cross entropy loss, $\alpha$ and $$, where $$ controls the weight of positive and negative samples and $$ scales the loss of hard and easy samples.

So, for the $i^{th}$ class:
$L_{class_i}=\begin{cases}
(1-p)^\log(p),& \text{if y=1} \\
(1-)p^\log(1-p),& \text{otherwise}
\end{cases}
$, where $y$ is the ground truth and $p$ is the model's prediction.

In our experiments we noticed worse results for values of $$ different from 1, so we deleted this parameter and kept just the focusing parameter $$.
"""

class FocalLoss(nn.Module):
    def __init__(self, alpha=1, gamma=2):
        super(FocalLoss, self).__init__()
        #self.alpha = alpha
        self.gamma = gamma
        self.BCE = torch.nn.BCEWithLogitsLoss(reduction='none')

    def forward(self, inputs, targets):
        BCE_loss = self.BCE(inputs,targets)
        pt = torch.exp(-BCE_loss)
        #F_loss = self.alpha * (1-pt)**self.gamma * BCE_loss
        F_loss =  (1-pt)**self.gamma * BCE_loss

        return torch.mean(F_loss)

"""## Lightning DataModule"""

class Task1DataModule(LightningDataModule):
    def __init__(
        self,
        train_data,
        test_data,
        le,
        val_data,
        techniques,
        num_classes: int = 20,
        model_name: str = "google/electra-base-discriminator",
        batch_size: int = 8,
        **kwargs,
    ):
        super().__init__()
        self.train_data = train_data
        self.test_data = test_data
        self.val_data = val_data
        self.techniques = techniques
        self.batch_size = batch_size
        self.num_classes = num_classes
        self.tokenizer = AutoTokenizer.from_pretrained(
            model_name, do_lower_case=False)
        self.mlb = MultiLabelBinarizer()
        self.le=le
    def setup(self, stage: str = None):
        self.X_train = self.train_data.text.values
        self.mlb.fit(self.techniques)
        y_train = self.mlb.transform(self.train_data.labels.values)

        self.X_test = self.test_data.text.values
        y_test = self.mlb.transform(self.test_data.labels.values)

        self.X_val = self.val_data.text.values
        y_val = self.mlb.transform(self.val_data.labels.values)

        self.max_length = self.maxLen()

        self.X_train_enc, self.X_train_attention = self.preprocessing(
            self.X_train)
        self.X_val_enc, self.X_val_attention = self.preprocessing(
            self.X_val)
        self.X_test_enc, self.X_test_attention = self.preprocessing(
            self.X_test)

        self.y_train = torch.tensor(y_train)
        self.y_val = torch.tensor(y_val)
        self.y_test = torch.tensor(y_test)

    def prepare_data(self):
        return

    def train_dataloader(self):
        data = Task1Dataset(
            self.X_train_enc, self.X_train_attention, self.y_train)
        train_dataloader = DataLoader(data, batch_size=self.batch_size)
        return train_dataloader

    def val_dataloader(self):
        data = Task1Dataset(self.X_val_enc, self.X_val_attention, self.y_val)
        val_dataloader = DataLoader(data, batch_size=self.batch_size)
        return val_dataloader

    def test_dataloader(self):
        data = Task1Dataset(
            self.X_test_enc, self.X_test_attention, self.y_test)
        test_dataloader = DataLoader(data, batch_size=self.batch_size)
        return test_dataloader

    def preprocessing(self, data):
        input_ids = []
        attention_masks = []

        for sent in data:
            preprocessed_sent = sent.replace(
                '\\', "").replace('\n', ' ').strip()
            encoded_sent = self.tokenizer.encode_plus(
                text=preprocessed_sent,
                add_special_tokens=True,
                max_length=self.max_length,
                pad_to_max_length=True,
                truncation=True,
                return_attention_mask=True
            )

            input_ids.append(encoded_sent.get('input_ids'))
            attention_masks.append(encoded_sent.get('attention_mask'))

        input_ids = torch.tensor(input_ids)
        attention_masks = torch.tensor(attention_masks)
        return input_ids, attention_masks

    def maxLen(self):
        tmp = np.concatenate([self.X_train, self.X_test])
        X_all = np.concatenate([tmp, self.X_val])

        encoded_X = [
            self.tokenizer.encode(
                sent,
                add_special_tokens=True
            ) for sent in X_all
        ]

        max_len = max([len(sent) for sent in encoded_X])
        return max_len

dm = Task1DataModule(train_data1, test_data1, val_data=dev_data1,le=2.00e-05, techniques=techniques,
                      model_name=pretrained_transformer_name, batch_size=8)
dm.setup()

"""## Subtask 1 Model

Class that implements the callback that prints the metrics that are used to evaluate a model.
"""

class Task1EvaluateCallback(Callback):
    def on_fit_end(self, trainer, model):
        print("Fit end: Evaluation....")

        all_predictions = model.predictions.int()
        all_labels = model.labels.int()

        classes = model.mlb.classes_

        self.print_evaluation(all_predictions, all_labels,
                              classes, model.num_classes)

        model.predictions = torch.Tensor()
        model.labels = torch.Tensor()

        return

    def on_test_end(self, trainer, model):
        print("Test metrics:")

        all_predictions = model.predictions.int()
        all_labels = model.labels.int()

        classes = model.mlb.classes_

        self.print_evaluation(all_predictions, all_labels,
                              classes, model.num_classes)

        model.predictions = torch.Tensor()
        model.labels = torch.Tensor()

        return

    def print_evaluation(self, all_predictions, all_labels, classes, num_classes):
        all_predictions = all_predictions.detach().cpu()
        all_labels = all_labels.detach().cpu()

        confMatrix = torchmetrics.ConfusionMatrix(task="multilabel", num_labels=num_classes)
        conf_mat = confMatrix(all_predictions, all_labels)
        plot_confusion_multi(conf_mat, classes)

        print("F1-micro: {}".format(f1_score(all_labels,
              all_predictions, average="micro", zero_division=1)))
        print("F1-macro: {}".format(f1_score(all_labels,
              all_predictions, average="macro", zero_division=1)))

        print(classification_report(all_labels, all_predictions, labels=[
              i for i in range(num_classes)], target_names=classes, zero_division=1))

        return

"""In this section we load the transformer model previously trained on PTC dataset by passing its name as input to the Task1Model class and then we add a classifier on top of it that takes the [CLS] token from the transformer as input. This classifier is composed by two layers with Dropout and as activation function ReLU."""

class Identity(nn.Module):
    def __init__(self):
        super(Identity, self).__init__()

    def forward(self, x):
        return x

class Task1Model(LightningModule):
    def __init__(
        self,
        mlb,
        y_train,
        le,
        num_classes: int = 20,
        model_name_or_path: str = "google/electra-base-discriminator",
        learning_rate: float = 2e-5,
        adam_epsilon: float = 1e-8,
        warmup_steps: int = 500,
        weight_decay: float = 0.1,
        batch_size: int = 8,
        **kwargs,
    ):
        super().__init__()  # Correct initialization

        self.mlb = mlb
        self.learning_rate = learning_rate
        self.adam_epsilon = adam_epsilon
        self.warmup_steps = warmup_steps
        self.weight_decay = weight_decay
        self.batch_size = batch_size
        self.save_hyperparameters()
        self.le = le
        self.threshold = 0.5
        self.outputs = []
        self.num_classes = num_classes

        #self.loss = torch.nn.BCEWithLogitsLoss()
        self.loss = FocalLoss()
        #self.loss = WeightedBCELoss(y_train)
        self.acc = torchmetrics.Accuracy(task='multilabel', num_labels=num_classes)

        self.register_buffer("labels", torch.Tensor())
        self.register_buffer("predictions", torch.Tensor())

        D_in, H, D_out = 768, 96, self.num_classes
        loaded_model = PTCTransformer.load_from_checkpoint('/content/drive/MyDrive/DeepProject/Model/PTC/PTC_google_electra-base-discriminator_FL.ckpt')
        self.transformer = loaded_model
        self.transformer.classifier = Identity()

        self.classifier = nn.Sequential(
            nn.Linear(D_in, H),
            nn.ReLU(),
            nn.Dropout(0.1),
            nn.Linear(H, D_out)
        )

    def forward(self, **inputs):
        cls_output = self.transformer(**inputs)
        logits = self.classifier(cls_output)
        return logits

    def training_step(self, batch, batch_idx):
        labels = batch["labels"]
        logits = self(**batch)
        loss = self.loss(logits, labels.to(torch.float32))
        self.log('train_loss', loss, prog_bar=True,
                 on_epoch=True, on_step=True,  logger=True)
        predictions = (torch.sigmoid(logits) > self.threshold).int()
        acc = self.acc(predictions, labels)
        self.log('train_acc', acc, prog_bar=True,
                 on_epoch=True, on_step=True,  logger=True)

        return {"loss": loss, "accuracy": acc}

    def validation_step(self, batch, batch_idx, dataloader_idx=0):
        logits = self(**batch)
        labels = batch["labels"]
        val_loss = self.loss(logits, labels.to(torch.float32))
        self.log('val_loss', val_loss, prog_bar=True,
                 on_epoch=True, on_step=True,  logger=True)
        predictions = (torch.sigmoid(logits) > self.threshold).int()
        acc = self.acc(predictions, labels)
        self.log('val_acc', acc, prog_bar=True,
                 on_epoch=True, on_step=True,  logger=True)
        self.outputs.append({"loss": val_loss, "accuracy": acc, # Append outputs to self.outputs
                "predictions": predictions, "labels": labels})
        return {"loss": val_loss, "accuracy": acc,
                "predictions": predictions, "labels": labels}

    def validation_step_end(self, outputs):
        self.outputs.append(outputs)  # Append the outputs to the list
        return outputs

    def on_validation_epoch_end(self):
        if self.current_epoch == self.trainer.max_epochs - 1:
            # Debug print to check if outputs list is empty
            print(f"Outputs length: {len(self.outputs)}")

            if len(self.outputs) == 0:
                print("Warning: No outputs collected during validation.")
                return

            labels = [x["labels"] for x in self.outputs]
            self.labels = torch.cat(labels, dim=0)

            predictions = [x["predictions"] for x in self.outputs]
            self.predictions = torch.cat(predictions, dim=0)

            self.outputs = []  # Clear the outputs list

    def test_step(self, batch, batch_idx, dataloader_idx=0):
        logits = self(**batch)
        labels = batch["labels"]
        test_loss = self.loss(logits, labels.to(torch.float32))
        self.log('test_loss', test_loss, prog_bar=True, logger=True)
        predictions = (torch.sigmoid(logits) > self.threshold).int()
        acc = self.acc(predictions, labels)
        self.log('test_acc', acc, prog_bar=True, logger=True)

        self.labels = torch.cat((self.labels, labels), 0)
        self.predictions = torch.cat((self.predictions, predictions), 0)
        return {"loss": test_loss, "accuracy": acc}

    def predict_step(self, batch, batch_idx, dataloader_idx=0):
        logits = self(**batch)
        predictions = (torch.sigmoid(logits) >
                       self.threshold).int().detach().cpu().numpy()
        return self.mlb.inverse_transform(predictions)

    def configure_optimizers(self):
        no_decay = ["bias", "LayerNorm.weight"]
        optimizer_grouped_parameters = [
            {
                "params": [p for n, p in self.named_parameters() if not any(nd in n for nd in no_decay)],
                "weight_decay": self.weight_decay,
            },
            {
                "params": [p for n, p in self.named_parameters() if any(nd in n for nd in no_decay)],
                "weight_decay": 0.0,
            },
        ]
        optimizer = AdamW(optimizer_grouped_parameters,
                          lr=self.learning_rate, eps=self.adam_epsilon)

        return [optimizer]

"""## Train and Validation"""

model = Task1Model(
    mlb=dm.mlb,      # Optional
    y_train=dm.y_train,  # Optional
    le=dm.le,  # Pass le appropriately
    num_classes=20,  # Specify the number of classes
    model_name_or_path=checkpoint_name  # Checkpoint path
)

log_dir = logs_dir+"SubTask1/"

logger = TensorBoardLogger(
    log_dir, name="SubTask1_net_"+checkpoint_name, version="TEST", log_graph=True)

import pytorch_lightning as pl

my_trainer=pl.Trainer(max_epochs=10,accelerator="gpu",devices=AVAIL_GPUS,logger=logger,callbacks=[Task1EvaluateCallback()])

my_trainer.fit(model, dm)

"""This command is used to save checkpoints needed for the ensemble.

It is commented to not overwrite the checkpoints of the best performing model already saved.
"""

my_trainer.save_checkpoint(Task1_checkpoints+"SubTask1_"+checkpoint_name+"_FL.ckpt")

"""## Testing"""

my_trainer.test(model, dm)

"""## Example prediction

Print some predictions made from the model on few samples and their true labels.
"""

predict_dataloader = dm.test_dataloader()
predictions = my_trainer.predict(model, predict_dataloader)

for i in range(5):
    text = test_data1.text.values[i].replace(
        '\\', "").replace('\n', ' ').strip()
    labels = test_data1.labels.values[i]
    preds = predictions[0][i]
    print("Text: '{}'".format(text))
    print("Predicted techniques: {}".format(preds))
    print("Correct techniques: {}".format(labels))
    print("-"*180)

"""The best results are obtained with the following configuration of the main parameters:

| Parameters (TASK 1) 	|          	|
|:-------------------:	|:--------:	|
|       Dropout       	|   0.10   	|
|      Batch Size     	|     8    	|
|    Learning Rate    	| 2,00E-05 	|
|      Optimizer      	|   AdamW  	|
|    Warm Up Steps    	|    500   	|
|     Weight Decay    	|    0.1   	|
|     Adam Epsilon    	| 1,00E-08 	|
|        Epochs       	|    10    	|

In the following tables are reported some of the tests done for this subtask.

Models fine-tuned on PTC are slightly better than the ones that are taken directly from HuggingFace library.

|          Model         	| Epochs 	|       Loss      	| F1 micro 	| F1 macro 	| F1 micro test 	| F1 macro test 	|
|:----------------------:	|:------:	|:---------------:	|:--------:	|:--------:	|:-------------:	|:-------------:	|
| **Bert base (no PTC)** 	|   10   	|    Focal loss   	|   0.47   	|   0.24   	|      0.38     	|      0.06     	|
| **Bert base (no PTC)** 	|   20   	| WeightedBCELoss 	|   0.46   	|   0.33   	|      0.37     	|      0.13     	|
|                        	|        	|                 	|          	|          	|               	|               	|
|   **Bert base (PTC)**  	|   10   	|    Focal loss   	|   0.53   	|   0.31   	|      0.47     	|      0.10     	|
|   **Bert base (PTC)**  	|   20   	| WeightedBCELoss 	|   0.53   	|   0.37   	|      0.44     	|      0.20     	|

In general models with Focal Loss got better results compared to plain BCE Loss and Weighted BCE Loss.

AdamW and Adam got very similar results.

The model that has the best F1-score is DeBerta base, but this was predictable since it is the biggest model.

|    Model (TASK 1)   	|       Loss       	|    DEV-SET   	|              	|   TEST-SET   	|              	|        Scheduler       	|
|:-------------------:	|:----------------:	|:------------:	|:------------:	|:------------:	|:------------:	|:----------------------:	|
|                     	|                  	| **F1-micro** 	| **F1-macro** 	| **F1-micro** 	| **F1-macro** 	|                        	|
|       **BERT**      	|        BCE       	|     0.53     	|     0.25     	|     0.47     	|     0.08     	|            -           	|
|                     	|                  	|     0.54     	|     0.25     	|     0.47     	|     0.09     	| Constant  with warmups 	|
|       **BERT**      	|  WeightedBCELoss 	|     0.45     	|     0.31     	|     0.36     	|     0.18     	|            -           	|
|                     	|                  	|     0.38     	|     0.24     	|     0.33     	|     0.17     	| Constant  with warmups 	|
|       **BERT**      	|     FocalLoss    	|     0.53     	|     0.31     	|     0.47     	|     0.10     	|            -           	|
|                     	|                  	|     0.51     	|     0.24     	|     0.44     	|     0.09     	| Constant  with warmups 	|
|                     	|                  	|              	|              	|              	|              	|                        	|
|      **ALBERT**     	|        BCE       	|     0.57     	|     0.25     	|     0.49     	|     0.08     	|            -           	|
|                     	|                  	|     0.53     	|     0.24     	|     0.44     	|     0.09     	| Constant  with warmups 	|
|      **ALBERT**     	|  WeightedBCELoss 	|     0.48     	|     0.30     	|     0.43     	|     0.15     	|            -           	|
|                     	|                  	|     0.44     	|     0.28     	|     0.40     	|     0.19     	| Constant  with warmups 	|
|      **ALBERT**     	|     FocalLoss    	|     0.56     	|     0.27     	|     0.50     	|     0.10     	|            -           	|
|                     	|                  	|     0.53     	|     0.28     	|     0.50     	|     0.11     	| Constant  with warmups 	|
|                     	|                  	|              	|              	|              	|              	|                        	|
|     **RoBERTa**     	|        BCE       	|     0.55     	|     0.25     	|     0.48     	|     0.08     	|            -           	|
|                     	|                  	|     0.52     	|     0.24     	|     0.47     	|     0.08     	| Constant  with warmups 	|
|     **RoBERTa**     	|  WeightedBCELoss 	|     0.50     	|     0.33     	|     0.36     	|     0.19     	|            -           	|
|                     	|                  	|     0.42     	|     0.26     	|     0.36     	|     0.20     	| Constant  with warmups 	|
|     **RoBERTa**     	|     FocalLoss    	|     0.55     	|     0.30     	|     0.49     	|     0.12     	|            -           	|
|                     	|                  	|     0.49     	|     0.27     	|     0.44     	|     0.09     	| Constant  with warmups 	|
|                     	|                  	|              	|              	|              	|              	|                        	|
|     **DeBERTa**     	|        BCE       	|     0.51     	|     0.24     	|     0.50     	|     0.09     	|            -           	|
|                     	|                  	|     0.53     	|     0.23     	|     0.46     	|     0.08     	| Constant  with warmups 	|
|     **DeBERTa**     	| WeightedBCELoss  	|     0.56     	|     0.50     	|     0.41     	|     0.24     	|            -           	|
|                     	|                  	|     0.47     	|     0.33     	|     0.38     	|     0.22     	| Constant  with warmups 	|
|     **DeBERTa**     	|    FocalLoss     	|     0.57     	|     0.33     	|     0.52     	|     0.13     	|            -           	|
|                     	|                  	|     0.60     	|     0.32     	|     0.49     	|     0.13     	| Constant  with warmups 	|
|                     	|                  	|              	|              	|              	|              	|                        	|
|      **XLNet**      	|        BCE       	|     0.50     	|     0.30     	|     0.49     	|     0.13     	|            -           	|
|                     	|                  	|     0.50     	|     0.26     	|     0.48     	|     0.10     	| Constant  with warmups 	|
|      **XLNet**      	|  WeightedBCELoss 	|     0.55     	|     0.33     	|     0.43     	|     0.21     	|            -           	|
|                     	|                  	|     0.44     	|     0.33     	|     0.38     	|     0.21     	| Constant  with warmups 	|
|      **XLNet**      	|     FocalLoss    	|     0.54     	|     0.35     	|     0.49     	|     0.13     	|            -           	|
|                     	|                  	|     0.58     	|     0.33     	|     0.44     	|     0.10     	| Constant  with warmups 	|
|                     	|                  	|              	|              	|              	|              	|                        	|
| **Random Baseline** 	|                  	|     0.06     	|     0.04     	|     0.05     	|     0.03     	|                        	|

## Ensemble
"""

model_names = ["bert-base-cased", "roberta-base",
               "xlnet-base-cased", "microsoft/deberta-base", "albert-base-v2"]

"""### Dataset and DataModule"""

class EnsemblerDataset(Dataset):
    def __init__(self, data_dict, labels):
        self.data_dict = data_dict
        self.labels = labels

    def __len__(self):
        return len(self.labels)

    def __getitem__(self, idx):
        sample_dict = {}
        for model in self.data_dict.keys():
            sample_dict[model] = {}
            attention = self.data_dict[model]["attention_mask"][idx]
            input_id = self.data_dict[model]["input_ids"][idx]
            sample_dict[model] = {
                "attention_mask": attention, "input_ids": input_id}

        sample_dict["labels"] = self.labels[idx]
        return sample_dict

class EnsemblerDataModule(LightningDataModule):
    def __init__(
        self,
        test_data,
        techniques,
        models_list: list,
        num_classes: int = 20,
        batch_size: int = 8,
        **kwargs,
    ):
        super().__init__()

        self.test_data = test_data
        self.techniques = techniques
        self.batch_size = batch_size
        self.num_classes = num_classes
        self.models = models_list
        self.mlb = MultiLabelBinarizer()
        self.max_length = 512

    def setup(self, stage: str = None):
        self.mlb.fit(self.techniques)

        self.X_test = self.test_data.text.values
        y_test = self.mlb.transform(self.test_data.labels.values)

        self.X_dict = self.preprocessing(self.X_test)

        self.y_test = torch.tensor(y_test)

    def prepare_data(self):
        return

    def test_dataloader(self):
        data = EnsemblerDataset(self.X_dict, self.y_test)
        test_dataloader = DataLoader(data, batch_size=self.batch_size)
        return test_dataloader

    def preprocessing(self, data):
        data_dict = {}
        for model_name in self.models:
            data_dict[model_name] = {}
            input_ids, attention_masks = self.preprocessing_for_model(
                data, model_name)
            data_dict[model_name]["input_ids"] = input_ids
            data_dict[model_name]["attention_mask"] = attention_masks

        return data_dict

    def preprocessing_for_model(self, data, model_name):
        tokenizer = AutoTokenizer.from_pretrained(
            model_name, do_lower_case=False)

        input_ids = []
        attention_masks = []

        for sent in data:
            preprocessed_sent = sent.replace(
                '\\', "").replace('\n', ' ').strip()
            encoded_sent = tokenizer.encode_plus(
                text=preprocessed_sent,
                add_special_tokens=True,
                max_length=self.max_length,
                pad_to_max_length=True,
                truncation=True,
                return_attention_mask=True
            )

            input_ids.append(encoded_sent.get('input_ids'))
            attention_masks.append(encoded_sent.get('attention_mask'))

        input_ids = torch.tensor(input_ids)
        attention_masks = torch.tensor(attention_masks)
        return input_ids, attention_masks

dm = EnsemblerDataModule(
    test_data1, techniques=techniques, models_list=model_names, batch_size=8)
dm.setup()

"""### Ensembler with Mean"""

class Ensembler(LightningModule):
    def __init__(self,
                 mlb,
                 model_names,
                 num_classes: int = 20,
                 threshold=0.5
                 ):
        super().__init__()
        self.model_names = model_names
        self.mlb = mlb
        self.num_classes = num_classes
        self.n_models = len(self.model_names)
        self.threshold = threshold
        print("Number of models in the ensemble: {}".format(self.n_models))
        self.models = self.load_models()

        self.register_buffer("labels", torch.Tensor())
        self.register_buffer("predictions", torch.Tensor())

    def forward(self, batch):
        preds = []
        for model_name in self.model_names:
            model = self.models[model_name]
            model.freeze()
            b = batch[model_name]

            x = model(**b)
            preds.append(x)
        preds = torch.stack(preds)
        logits = torch.mean(preds, axis=0)
        pred = (torch.sigmoid(logits) > self.threshold).int()
        return pred

    def predict_step(self, batch, batch_idx, dataloader_idx=0):
        return self(batch)

    def test_step(self, batch, batch_idx, dataloader_idx=0):
        predictions = self(batch)
        labels = batch["labels"]
        self.labels = torch.cat((self.labels, labels), 0)
        self.predictions = torch.cat((self.predictions, predictions), 0)
        return

    def load_models(self):
        models = {}
        for model_name in model_names:
            checkpoint_name = model_name.replace("/", "_")
            ckpt_path = Task1_checkpoints+"SubTask1_"+checkpoint_name+"_FL.ckpt"
            loaded_model = Task1Model.load_from_checkpoint(
                checkpoint_path=ckpt_path)
            models[model_name] = loaded_model.to(device)
        return models

ensemble = Ensembler(dm.mlb, model_names=model_names)

trainer = Trainer(max_epochs=1, gpus=AVAIL_GPUS, callbacks=[
                  Task1EvaluateCallback()])

trainer.test(ensemble, dm)

predict_dataloader = dm.test_dataloader()
predictions = trainer.predict(ensemble, predict_dataloader)

for i in range(5):
    text = test_data1.text.values[i].replace(
        '\\', "").replace('\n', ' ').strip()
    labels = test_data1.labels.values[i]
    predicted_classes = dm.mlb.inverse_transform(predictions[0])
    print("Text: '{}'".format(text))
    print("Predicted techniques: {}".format(predicted_classes[i]))
    print("Correct techniques: {}".format(labels))
    print("-"*180)